"""Abstract Base Classes for the Vector Store components."""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, Dict, List, Set, Union

from crossvector.logger import Logger
from crossvector.querydsl.compilers.base import BaseWhere
from crossvector.settings import settings as api_settings

from .schema import VectorDocument

if TYPE_CHECKING:
    from crossvector.querydsl.q import Q


class EmbeddingAdapter(ABC):
    """Abstract base class for embedding providers."""

    def __init__(self, model_name: str, dim: int = None, logger: Logger = None, **kwargs: Any):
        self.model_name = model_name
        self._dim = dim or api_settings.VECTOR_DIM
        self._logger = logger if isinstance(logger, Logger) else Logger(self.__class__.__name__)

    @property
    def logger(self) -> Logger:
        return self._logger

    @property
    def dim(self) -> int:
        """The dimension of the embeddings generated by the model."""
        return self._dim

    @abstractmethod
    def get_embeddings(self, texts: List[str]) -> List[List[float]]:
        """
        Generates embeddings for a list of texts.

        Args:
            texts: A list of strings to embed.

        Returns:
            A list of embedding vectors.
        """
        raise NotImplementedError


class VectorDBAdapter(ABC):
    """Abstract base class for vector database adapters.

    Provides a standardized interface for vector database operations including
    collection management, CRUD operations, and batch processing. All concrete
    adapters must implement these abstract methods to ensure consistent behavior
    across different vector database backends.

    Attributes:
        use_dollar_vector: Whether to use '$vector' key (True) or 'vector' key (False)
            for vector field storage. Default is False.
    """

    use_dollar_vector: bool = False
    supports_metadata_only: bool = False
    where_compiler: BaseWhere = None

    def __init__(
        self,
        collection_name: str | None = None,
        dim: int | None = None,
        store_text: bool | None = None,
        logger: Logger = None,
        **kwargs: Any,
    ) -> None:
        """Initialize vector database adapter with common configuration.

        Args:
            collection_name: Collection name (default from api_settings.VECTOR_COLLECTION_NAME)
            dim: Vector dimension (default from settings.VECTOR_DIM)
            store_text: Whether to store text (default from settings.VECTOR_STORE_TEXT)
            logger: Custom logger instance
            **kwargs: Additional adapter-specific configuration
        """
        self._logger = logger if isinstance(logger, Logger) else Logger(self.__class__.__name__)
        self.collection_name: str = collection_name or api_settings.VECTOR_COLLECTION_NAME
        self.dim: int = dim or api_settings.VECTOR_DIM
        self.store_text: bool = store_text if store_text is not None else api_settings.VECTOR_STORE_TEXT
        self._logger.message(
            "%s initialized: collection_name=%s, dim=%s, store_text=%s",
            self.__class__.__name__,
            self.collection_name,
            self.dim,
            self.store_text,
        )
        self._client: Any = None
        self._collection: Any = None

    @property
    def logger(self) -> Logger:
        return self._logger

    @property
    def collection(self) -> Any:
        """Lazily return the adapter-specific collection object.

        For AstraDB, this is the Collection instance.
        For other adapters, this remains None or can be overridden.
        """
        return self._collection

    @collection.setter
    def collection(self, value: Any) -> None:
        """Set the collection object."""
        self._collection = value

    @abstractmethod
    def initialize(self, collection_name: str, dim: int, metric: str = "cosine", **kwargs: Any) -> None:
        """Initialize the database and ensure the collection is ready for use.

        Args:
            collection_name: Name of the collection to initialize
            dim: Dimension of vector embeddings to be stored
            metric: Distance metric for vector similarity search
                ('cosine', 'euclidean', 'dot_product'). Default is 'cosine'.
            **kwargs: Additional adapter-specific configuration options

        Raises:
            ConnectionError: If database connection fails
            InvalidConfigError: If configuration parameters are invalid
        """
        raise NotImplementedError

    @abstractmethod
    def add_collection(self, collection_name: str, dim: int, metric: str = "cosine") -> Any:
        """Create a new collection in the vector database.

        Args:
            collection_name: Name for the new collection
            dim: Dimension of vector embeddings
            metric: Distance metric for vector search ('cosine', 'euclidean', 'dot_product').
                Default is 'cosine'.

        Returns:
            The collection object or handle specific to the backend

        Raises:
            CollectionExistsError: If collection with the same name already exists
            ConnectionError: If database connection fails
        """
        raise NotImplementedError

    @abstractmethod
    def get_collection(self, collection_name: str) -> Any:
        """Retrieve an existing collection from the vector database.

        Args:
            collection_name: Name of the collection to retrieve

        Returns:
            The collection object or handle specific to the backend

        Raises:
            CollectionNotFoundError: If collection doesn't exist
            ConnectionError: If database connection fails
        """
        raise NotImplementedError

    @abstractmethod
    def get_or_create_collection(self, collection_name: str, dim: int, metric: str = "cosine") -> Any:
        """Get existing collection or create if it doesn't exist.

        Args:
            collection_name: Name of the collection
            dim: Dimension of vector embeddings (used if creating)
            metric: Distance metric for vector search ('cosine', 'euclidean', 'dot_product').
                Default is 'cosine'.

        Returns:
            The collection object or handle specific to the backend

        Raises:
            ConnectionError: If database connection fails
        """
        raise NotImplementedError

    @abstractmethod
    def drop_collection(self, collection_name: str) -> bool:
        """Delete a collection and all its documents from the database.

        Args:
            collection_name: Name of the collection to drop

        Returns:
            True if collection was successfully dropped

        Raises:
            ConnectionError: If database connection fails
        """
        raise NotImplementedError

    @abstractmethod
    def clear_collection(self) -> int:
        """Delete all documents from the current collection.

        Returns:
            Number of documents deleted

        Raises:
            CollectionNotInitializedError: If collection is not initialized
        """
        raise NotImplementedError

    @abstractmethod
    def count(self) -> int:
        """Count total number of documents in the current collection.

        Returns:
            Total document count

        Raises:
            CollectionNotInitializedError: If collection is not initialized
        """
        raise NotImplementedError

    @abstractmethod
    def search(
        self,
        vector: List[float] | None = None,
        limit: int | None = None,
        offset: int = 0,
        where: Union[Dict[str, Any], "Q", None] = None,
        fields: Set[str] | None = None,
    ) -> List[VectorDocument]:
        """Perform vector similarity search to find nearest neighbors.

        Args:
            vector: Query vector embedding to search for. If None, performs metadata-only query.
            limit: Maximum number of results to return. If None, uses VECTOR_SEARCH_LIMIT from settings.
            offset: Number of results to skip (for pagination). Default is 0.
            where: Optional metadata filter conditions. Can be:
                - Q object: QueryDSL object for complex filters (supports &, |, ~)
                  Example: Q(age__gte=18) & Q(status="active")
                - Dict: Universal dict format with operators
                  Example: {"age": {"$gte": 18}, "status": {"$eq": "active"}}
                Only documents matching all conditions will be returned.
            fields: Optional set of field names to include in results.
                If None, returns all fields except vector by default.

        Returns:
            List of VectorDocument instances ordered by similarity score (most similar first)
            when vector is provided, or arbitrary order when vector is None.

        Raises:
            CollectionNotInitializedError: If collection is not initialized
            InvalidFieldError: If vector dimension doesn't match collection dimension (when vector provided)
        """
        raise NotImplementedError

    @abstractmethod
    def get(self, *args, **kwargs) -> VectorDocument:
        """Retrieve a single document by key or metadata.

        Django-style semantics:
        - Priority 1: If a positional `pk` or keyword `pk/id/_id` is provided, fetch by primary key.
        - Priority 2: Use remaining kwargs as metadata filter. Must return exactly one row.

        Args:
            *args: Optional positional `pk` value.
            **kwargs: Metadata fields for filtering (e.g., name="value", status="active")
                     Special keys: `pk`/`id`/`_id` for primary key lookup

        Returns:
            VectorDocument instance

        Raises:
            CollectionNotInitializedError: If collection is not initialized
            MissingFieldError: If input is invalid (no pk and no metadata kwargs)
            DoesNotExist: If no document matches filter
            MultipleObjectsReturned: If more than one document matches filter
        """
        raise NotImplementedError

    @abstractmethod
    def create(self, doc: VectorDocument) -> VectorDocument:
        """Create and persist a single document in the collection.

        Args:
            doc: VectorDocument instance to create (must have vector)

        Returns:
            Created VectorDocument instance

        Raises:
            CollectionNotInitializedError: If collection is not initialized
            DocumentExistsError: If document with same pk already exists
            MissingFieldError: If required fields are missing
        """
        raise NotImplementedError

    @abstractmethod
    def bulk_create(
        self,
        docs: List[VectorDocument],
        batch_size: int = None,
        ignore_conflicts: bool = False,
        update_conflicts: bool = False,
        update_fields: List[str] = None,
    ) -> List[VectorDocument]:
        """Create multiple documents in batch for improved performance.

        Args:
            docs: List of VectorDocument instances to create
            batch_size: Number of documents per batch (optional, uses adapter default)
            ignore_conflicts: If True, skip documents with conflicting pk
            update_conflicts: If True, update existing documents on pk conflict
            update_fields: Fields to update on conflict (only used if update_conflicts=True,
                None means update all fields)

        Returns:
            List of successfully created VectorDocument instances

        Raises:
            CollectionNotInitializedError: If collection is not initialized
            DocumentExistsError: If conflict occurs and both ignore_conflicts and update_conflicts are False
        """
        raise NotImplementedError

    @abstractmethod
    def delete(self, *ids) -> int:
        """Delete documents by primary key.

        Args:
            *args: One or more document IDs to delete

        Returns:
            Number of documents successfully deleted

        Raises:
            CollectionNotInitializedError: If collection is not initialized
        """
        raise NotImplementedError

    @abstractmethod
    def update(self, doc: VectorDocument, **kwargs) -> VectorDocument:
        """Update existing document by pk.

        Strict update semantics: raises error if document doesn't exist.

        Args:
            doc: VectorDocument instance to update (must include valid id/pk)
            **kwargs: Optional backend-specific flags

        Returns:
            Updated VectorDocument instance

        Raises:
            CollectionNotInitializedError: If collection is not initialized
            MissingFieldError: If pk is missing
            DocumentNotFoundError: If document doesn't exist
        """
        raise NotImplementedError

    @abstractmethod
    def bulk_update(
        self,
        docs: List[VectorDocument],
        batch_size: int = None,
        ignore_conflicts: bool = False,
        update_fields: List[str] = None,
    ) -> List[VectorDocument]:
        """Update multiple existing documents by pk in batch.

        Args:
            docs: List of VectorDocument instances to update (each must have valid pk)
            batch_size: Number of updates per batch (optional, uses adapter default)
            ignore_conflicts: If True, skip documents that don't exist instead of raising error
            update_fields: Specific fields to update (None means update all fields except pk)

        Returns:
            List of successfully updated VectorDocument instances

        Raises:
            CollectionNotInitializedError: If collection is not initialized
            MissingDocumentError: If any document is missing and ignore_conflicts=False
        """
        raise NotImplementedError

    @abstractmethod
    def upsert(self, docs: List[VectorDocument], batch_size: int = None) -> List[VectorDocument]:
        """Insert new documents or update existing ones by pk in batch.

        Args:
            docs: List of VectorDocument instances to upsert
            batch_size: Number of documents per batch (optional, uses adapter default)

        Returns:
            List of upserted VectorDocument instances

        Raises:
            CollectionNotInitializedError: If collection is not initialized
            MissingFieldError: If required fields are missing
        """
        raise NotImplementedError
